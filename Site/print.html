<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chai Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="application.html"><strong aria-hidden="true">2.</strong> Application</a></li><li class="chapter-item expanded "><a href="scene.html"><strong aria-hidden="true">3.</strong> Scene</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scene_runtime.html"><strong aria-hidden="true">3.1.</strong> Runtime</a></li></ol></li><li class="chapter-item expanded "><a href="ecs.html"><strong aria-hidden="true">4.</strong> ECS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ECS/entity.html"><strong aria-hidden="true">4.1.</strong> Entity</a></li><li class="chapter-item expanded "><a href="ECS/component.html"><strong aria-hidden="true">4.2.</strong> Component</a></li><li class="chapter-item expanded "><a href="ECS/system.html"><strong aria-hidden="true">4.3.</strong> System</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chai Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="home"><a class="header" href="#home">Home</a></h1>
<p><em><strong>I would like to take a few lines to thank you, oh reader. for choosing to take some time off of your day and check this lightweight and humble engine.
This engine is the culmination of my very basic understanding of the underworkings of Game Engines,<br>
Beware though, for this engine might make you want to pluck your hairs, please bear with it.</strong></em></p>
<!-- ![Chai Logo](../resources/Chai_Logo_transparent.png) -->
<img src="../resources/Chai_Logo_transparent.png" class="logo">
<h3 id="tools-required"><a class="header" href="#tools-required">Tools Required</a></h3>
<ul>
<li>Go programming language</li>
<li>A modern web browser</li>
<li>A tool for hosting local servers (node/python)</li>
</ul>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<ul>
<li>Clone this repo <a href="https://github.com/mhamedGd/chai_examples">Chai Examples</a>.</li>
<li>Run "go get" in the root directory.</li>
<li>If you're using vscode then you can start right away, If you're using another code edit then you'd need to configure go for WASM build settings locally.</li>
</ul>
<h3 id="specifics"><a class="header" href="#specifics">Specifics</a></h3>
<ul>
<li>
<p>Chai is 2D, Web-focused, and Lightweight engine.</p>
</li>
<li>
<p>It uses WebAssembly through Go's WASM compiler to build Apps for the web.</p>
</li>
<li>
<p>Chai is an ECS based Game Engine. Which means that unlike OOP based Engines, Chai separates Logic from Data. Making the Components and Entities only data holders and identifiers. And having the logic be commonolized (generalized) amongst the specified components.</p>
</li>
<li>
<p>Current Cull Render Benchmark for Quads (no sprites) <a href="https://www.youtube.com/watch?v=YeYom1glrAk&amp;feature=youtu.be">Video</a></p>
</li>
</ul>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p><strong>In the "Chai Examples" folder, run:</strong></p>
<ul>
<li><strong>make build</strong> <em>Building the project</em></li>
<li><strong>make serve</strong> <em>Creating a local server for the project and opening it in the browser</em></li>
<li><strong>make run</strong> <em>Combines build and serve</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application"><a class="header" href="#application">Application</a></h1>
<pre><code class="language-go">type App struct {
	Width    int
	Height   int
	Title    string
	OnStart  func()
	OnUpdate func(float32)
	OnDraw   func(float32)
	OnEvent  func(*AppEvent)
}
</code></pre>
<p>An application is Chai's main entry point. It contains your App's info and life cycle.
It can be declared as a variable of type App.</p>
<pre><code class="language-go">var app chai.App = chai.App {
    Title: "",
    Width: 1920,
    Height: 1080,
    OnStart: func(){},
    OnUpdate: func(_delta_time float32){},
    OnDraw: func(_delta_time float32){},
    OnEvent func(_event *AppEvent){},
}
</code></pre>
<p>In order to run the Application, All You have to do is call "chai.Run(<em>application_variable_pointer</em>)" in the main file of your go project.</p>
<pre><code class="language-go">func main() {
    chai.Run(&amp;app)
}
</code></pre>
<p>If you try running <strong>make run</strong>, You'll get a looooong stream of errors in the console of the page. If you go all the way to the top you'll eventually see "Scene is set to none".</p>
<p>So next, we'll be discussing scenes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<pre><code class="language-go">type Scene struct {
	Background     RGBA8
	Ecs_World      *ecs.World
	start_systems  List[func(*Scene)]
	update_systems List[func(*Scene, float32)]
	render_systems List[func(*Scene, float32)]
	tags           Map[string, List[EntId]]
}

</code></pre>
<p>A scene is the container of your level's objects and logic. It is on align with Unity's understanding of a scene, Which states that scenes and objects (prefabs) are separate unlike Godot's.</p>
<p>You can create a scene inside an App's OnStart method.</p>
<pre><code class="language-go">OnStart: func(){
    _test_scene := chai.NewScene()
}
</code></pre>
<p>As we mentioned Chai is an ECS based Game Engine, Which means that Objects only contain data, while the logic is cluttered somewhere else</p>
<p>It goes like this</p>
<ul>
<li>Components are data holders (name, position, uv, speed, etc...)</li>
<li>Entities are Identifiers that point towards the specific component</li>
<li>Systems use the Entities to Get All the Components you would want to do logic on.</li>
</ul>
<h3 id="entities"><a class="header" href="#entities"><strong>Entities</strong></a></h3>
<p>An Entity is just an Id (uint32), Entities can be seen as a key in a dictionary. The key points to a specific value. And as such you can retrieve and manipulate the value thanks to the key pointing to its location.</p>
<p>In Game Engines, You'd typically think of Entities as Objects that hold <strong>Data</strong> and perform <strong>Logic</strong>. In ECS this definition would get dissected.</p>
<p><strong>Creating An Entity</strong> is very easy,</p>
<pre><code class="language-go">_entity := _test_scene.NewEntityId()
</code></pre>
<h3 id="components"><a class="header" href="#components"><strong>Components</strong></a></h3>
<p>A Component is any piece of data. Whether that be a struct or a native type, It can be turned into a component</p>
<pre><code class="language-go">type CustomComponent struct{
    u int
}
</code></pre>
<pre><code class="language-go">_entity := _test_scene_NewEntityId()
_component := CustomComponent{
    u: 0
}
_test_scene.AddComponents(_entity, chai.ToComponent(_component))
</code></pre>
<p>With this, The Engine has acknowledged that on this Scene, The component "_component" has been attached to this Identifier "_entity".</p>
<p><strong>Now how do we manipulate the component?</strong>
In Unity it would be something like getting a reference of the component in your script and then use it inside the script itself.</p>
<p>In Godot, You would either use the Node you've attached the script to or Get a reference to the Node you would want to manipulate.</p>
<p>Chai also needs to get a reference to the Component to use it like any other Engine, but the way we do that is different, Which takes us to <strong>Systems</strong>.</p>
<h3 id="systems"><a class="header" href="#systems"><strong>Systems</strong></a></h3>
<p>Systems are basically functions. They perform just like you would perform a function being called inside "Start" or "Update" in Unity(_ready, _process in Godot).</p>
<p><strong>Writing A System</strong></p>
<pre><code class="language-go">func CustomSystem(_this_scene *chai.Scene) {
    chai.LogF("Chaiiii")
}
</code></pre>
<p>Then you would need to add it to the scene.</p>
<pre><code class="language-go">_entity := _test_scene_NewEntityId()
_component := CustomComponent{
    u: 0
}
_test_scene.AddComponents(_entity, chai.ToComponent(_component))

_test_scene.NewStartSystem(CustomSystem)
</code></pre>
<p><strong>NewStartSystem</strong> is exactly that, It adds the System we just created into the Scene's Start runtime
Now what is a <strong>Scene runtime</strong>?</p>
<p>We'll be talking about it next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<p>Runtime is the concept of the Scene's run cycle, The Scene starts with "Start" Then it goes into cycling between "Update" and "Draw" every frame.</p>
<p><strong>There are 3 different Runtime:</strong></p>
<ul>
<li>Start</li>
<li>Update</li>
<li>Draw</li>
</ul>
<h3 id="start"><a class="header" href="#start">Start</a></h3>
<p>Start is called only once, At the start of the scene. It's useful for setting up the scene and creating Entities and Components.</p>
<p><strong>Adding A Start Runtime System</strong></p>
<pre><code class="language-go">func CustomSystem(_this_scene *chai.Scene) {

}
</code></pre>
<pre><code class="language-go">OnStart: func(){
    _test_scene := chai.NewScene()

    _test_scene.NewStartSystem(CustomSystem)
}
</code></pre>
<p>The first code is how you make a Start Runtime System. You just create a normal function and as a parameter you give a pointer of the scene this system will running on.</p>
<pre><code class="language-go">import (
	chai "github.com/mhamedGd/chai"
)

func CustomSystem(_this_scene *chai.Scene) {
    chai.LogF("Chai!!")
}

var app chai.App = chai.App{
    Title: "Docs",
    Width: 480,
    Height: 480,
    OnStart: func(){
        _test_scene := chai.NewScene()
        _test_scene.NewStartSystem(CustomSystem)

// Transition into this scene
        chai.ChangeScene(&amp;_test_scene)
    },
}

func main(){
    chai.Run(&amp;app)
}
</code></pre>
<p>Try then to run it "make run", Now the Output Should be like this.</p>
<p><em><strong>You can Access the Console with (Ctrl/Cmd + L.Shift + C)</strong></em></p>
<p><img src="../resources/start_runtime.png" alt="Start Output" /></p>
<h3 id="update"><a class="header" href="#update">Update</a></h3>
<p>Update just like Start is a runtime of Scene, but unlike Start it runs for every frame after Start, It's useful for game logic,</p>
<p><strong>Adding An Update Runtime System</strong></p>
<pre><code class="language-go">func CustomUpdateSystem(_this_scene *chai.Scene, _dt float32) {

}
</code></pre>
<pre><code class="language-go">OnStart: func(){
    _test_scene := chai.NewScene()

    _test_scene.NewUpdateSystem(CustomUpdateSystem)
}
</code></pre>
<p>Notice how here the Update Runtime System takes 2 parameters, not 1.
The first is a reference to the Scene the System is running on, While the Second is the delta-time of the updated frame.</p>
<pre><code class="language-go">import (
	chai "github.com/mhamedGd/chai"
)

func CustomUpdateSystem(_this_scene *chai.Scene, _dt float32) {
    chai.LogF("Chai Deltatime: %v", _dt)
}

var app chai.App = chai.App{
    Title: "Docs",
    Width: 480,
    Height: 480,
    OnStart: func(){
        _test_scene := chai.NewScene()
        _test_scene.NewUpdateSystem(CustomUpdateSystem)

// Transition into this scene
        chai.ChangeScene(&amp;_test_scene)
    },
}

func main(){
    chai.Run(&amp;app)
}
</code></pre>
<p>Try it now with "make run"</p>
<p><img src="../resources/update_runtime.png" alt="Update Runtime" /></p>
<h3 id="draw"><a class="header" href="#draw">Draw</a></h3>
<p>Draw is almost exactly the same as Update, the Difference is that it runs after Update in the Scene Life Cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs"><a class="header" href="#ecs">ECS</a></h1>
<p>Chai is a an ECS based game engine, That means it ditches the traditional way of handling objects and logic and instead resorts to separating the logic from entities (objects)</p>
<h2 id="ecs-workings"><a class="header" href="#ecs-workings">ECS Workings</a></h2>
<p>The way an ECS system works is by defining Entities that have Components attached to them and then applying logic unto those Components by exploiting Systems</p>
<p>If we compare the normal regular game engine, How you would normally go on implementing a new mechanic is that you would usually create a new Component or a Script attached to the Component. You would put the logic and the data required by the mechanic in the same section (class, script, etc...). And as such the Engine would loop through all Entities (Objects) in the scene and executes the logic provided by each component attached to the Entity.</p>
<p>In ECS it's a bit different. When you write a Component, You only fill it with data without any logic. You would attach this Component to an Entity, and By using a System you would be able to loop through all Entities with the required Component and execute the logic you want using the data provided by the Components.
This way, the logic is separate from the data and like that not only would it be cache friendly, it would also be more scalable since you would treat Entities with Components as data pointers and holders.</p>
<p>It probably sounded confusing but believe me, when you use it, you would feel way more comfortable dealing with it compared to a regular Entities/Components Engine.</p>
<p><a href="https://www.reddit.com/r/gamedev/comments/257mt1/entity_component_system_vs_entity_component/">Read this to have a broader view on the topic</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity"><a class="header" href="#entity">Entity</a></h1>
<p>An Entity is just an Identifier of type (uint32). It literally is just a number that points to multiple Components.
When you create a new Entity you get an Identifier, You use this Identifier to Attach Components to this Entity. Now you would ask, How can I attach Components to a uint32? It literally cannot hold any data other than of type unsigned int of siz 32 bit. Well here the magic of ECS starts working. What the ECS Engine in Chai would do is identifiy those Components added with this Identifier and as such it would be able to retrieve them efficiently.</p>
<p><strong>Creating a New Entity</strong></p>
<pre><code class="language-go">func TestSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()
}
</code></pre>
<p><em>If we print it out with "chai.LogF()" we get the following</em></p>
<p><strong>Output</strong></p>
<pre><code class="language-go">2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component"><a class="header" href="#component">Component</a></h1>
<p>A Component can be anything, A struct or an int or anything can become a Component. Using a converter method, You can have a custom type holding X data become a Component that interacts with the ECS Engine in the Scene.</p>
<p>You can then attach them to you Entity this way.</p>
<br>
<h3 id="attaching-a-component-to-an-entity"><a class="header" href="#attaching-a-component-to-an-entity">Attaching a Component to an Entity</a></h3>
<pre><code class="language-go">type Custom struct {
    data int
}

func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 0,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))
}
</code></pre>
<br>
<p><em><strong>Notice the "ToComponent" method. This method converts any type of data to a component that you can attach to your Entity</strong></em></p>
<h3 id="getting-the-component"><a class="header" href="#getting-the-component">Getting the Component</a></h3>
<pre><code class="language-go">type Custom struct {
    data int
}

func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 0,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))

    _c, ok := chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)
}
</code></pre>
<p><em><strong>output</strong></em></p>
<p><img src="ECS/../../resources/get_component.png" alt="Get Component Output" /></p>
<br>
<h3 id="removing-a-component"><a class="header" href="#removing-a-component">Removing a Component</a></h3>
<p>DestroyComponent[T any](scene *Scene, entityId EntId)</p>
<pre><code class="language-go">func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 10,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))

    _c, ok := chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)
    
    chai.DestroyComponent[Custom](_this_scene, _entity)
    _c, ok = chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)

}
</code></pre>
<p><strong>output</strong></p>
<p><img src="ECS/../../resources/destroy_component.png" alt="Destroy Component Output" /></p>
<br>
<h3 id="modifying-a-component"><a class="header" href="#modifying-a-component">Modifying a Component</a></h3>
<p>You can modify a Component by getting the Pointer of the Component and then modifying the underlying data directly</p>
<pre><code class="language-go">func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 10,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))

    _c, ok := chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)
    
    _cPtr := chai.GetComponentPtr[Custom](_this_scene, _entity)
    _cPtr.data = 20
    chai.LogF("Custom Struct: %v", _cPtr)
}
</code></pre>
<p><strong>output</strong>
<img src="ECS/../../resources/get_component_ptr.png" alt="Get ComponentPtr Output" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system"><a class="header" href="#system">System</a></h1>
<p>Systems are the executers of logic. They are the equivalent of "void Start", void "Update" in Unity, They hook unto the main application loop. Using Systems you can easily implement features in your game thanks to their flexible and modular usage.
In a Scene, there are 3 runtimes:</p>
<ul>
<li>Start</li>
<li>Update</li>
<li>Render</li>
</ul>
<p>Each runtime can have functions be subscribed to, and those functions will be called according to their order of addition.</p>
<p><strong>Here's an Example</strong></p>
<pre><code class="language-go">func TestStartSystem(_this_scene *chai.Scene) {
    chai.LogF("Test System")
}
</code></pre>
<p>Here we declare a new function with a single parameter "_this_scene" of type (Pointer to Scene). All the function does is print a message to the console.</p>
<hr />
<br>
<p><strong>How can I subscribe it to a runtime?</strong></p>
<h3 id="start-runtime"><a class="header" href="#start-runtime">Start Runtime</a></h3>
<pre><code class="language-go">var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(TestStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}
</code></pre>
<p>Here we're subscribing it to the start system of the Scene runtime, That means the function will get called when we first start the Scene.</p>
<p>The reason the function takes a parameter of a pointer to a Scene is that the runtime will pass the scene the function is currently subcribed to through this parameter, for the user to modify.</p>
<h4 id="the-start-runtime-is-usually-used-to-setup-the-scene-and-adding-entities-to-the-scene"><a class="header" href="#the-start-runtime-is-usually-used-to-setup-the-scene-and-adding-entities-to-the-scene">The Start runtime is usually used to setup the Scene and adding Entities to the Scene</a></h4>
<h3 id="update-runtime"><a class="header" href="#update-runtime">Update Runtime</a></h3>
<pre><code class="language-go">func TestUpdateSystem(_this_scene *chai.Scene, _delta float32) {
    chai.LogF("Test System")
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewUpdateSystem(TestUpdateSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}
</code></pre>
<p>Here we'e subscribing to the Update system of the Scene runtime, That means the function will get called once per frame during the lifetime of the game.</p>
<p>It takes 2 parameters, 1st is the current Scene pointer, and the 2nd is the delta-time between the current frame and the previous frame.</p>
<h4 id="the-update-runtime-is-useful-for-applying-game-logic-and-implementing-features"><a class="header" href="#the-update-runtime-is-useful-for-applying-game-logic-and-implementing-features">The Update runtime is useful for applying game logic and implementing features</a></h4>
<h3 id="render-runtime"><a class="header" href="#render-runtime">Render Runtime</a></h3>
<pre><code class="language-go">func TestRenderSystem(_this_scene *chai.Scene, _delta float32) {
    chai.LogF("Test System")
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewRenderSystem(TestRenderSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}
</code></pre>
<p>Here we'e subscribing to the Render system of the Scene runtime, That means the function will get called once per frame during the lifetime of the game.</p>
<p>It takes 2 parameters, 1st is the current Scene pointer, and the 2nd is the delta-time between the current frame and the previous frame.</p>
<h4 id="the-render-runtime-is-useful-for-calling-custom-drawing-commands-during-runtime"><a class="header" href="#the-render-runtime-is-useful-for-calling-custom-drawing-commands-during-runtime">The Render runtime is useful for calling custom drawing commands during runtime</a></h4>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p><strong>Let's use what we just learned to create an App that has a spinning square in the middle</strong></p>
<pre><code class="language-go">var rectRotation float32 = 0.0

func RectStartSystem(_this_scene *chai.Scene) {
    _this_scene.NewUpdateSystem(RectUpdateSystem)
	_this_scene.NewRenderSystem(RectRrenderSystem)
	
	chai.Shapes.LineWidth = 1
}

func RectUpdateSystem(_this_scene *chai.Scene, _delta float32) {
    rectRotation += _delta * 5.0
}

func RectRenderSystem(_this_scene *chai.Scene, _delta float32) {
	chai.Shapes.DrawRectRotated(chai.Vector2fZero, 0.0, chai.NewVector2f(20.0, 20.0), chai.WHITE, rectRotation)
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(RectStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}

func main(){
	chai.Run(&amp;app)
}
</code></pre>
<p><strong>output</strong></p>
<p><img src="ECS/../../resources/systems_example.gif" alt="Example Output" /></p>
<hr />
<p><strong>There's a lot to unfold here</strong></p>
<ul>
<li>We declared a new variable that will hold the Rect's rotation.</li>
<li>We declared a new function that will be added to the Start runtime.</li>
<li>Now instead of subscribing the Update and Render functions in the "OnStart" function, we did it in the Start runtime function, Why? So that this turns this function into a template, So that if any other scene would like similar results then all they need is to subscribe this function to their Start runtime.</li>
<li>We change the value of a float "LineWidth", inside an object called Shapes belonging to Chai.</li>
<li>In the Update function, we're only incrementing the rotation.</li>
<li>Now in the Render function, we're calling onto an object in chai called "Shapes" that holds all the functions needed to draw Shapes onto the screen, then we're calling the function "DrawRectRotated" that takes in
<ul>
<li>Center</li>
<li>Z</li>
<li>Dimensions</li>
<li>Color</li>
<li>Rotation (in degrees)</li>
</ul>
</li>
<li>Then we run the app in main</li>
</ul>
<hr />
<p>WIP</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

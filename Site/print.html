<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chai Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="application.html"><strong aria-hidden="true">2.</strong> Application</a></li><li class="chapter-item expanded "><a href="scene.html"><strong aria-hidden="true">3.</strong> Scene</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scene_runtime.html"><strong aria-hidden="true">3.1.</strong> Runtime</a></li></ol></li><li class="chapter-item expanded "><a href="ecs.html"><strong aria-hidden="true">4.</strong> ECS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ECS/entity.html"><strong aria-hidden="true">4.1.</strong> Entity</a></li><li class="chapter-item expanded "><a href="ECS/component.html"><strong aria-hidden="true">4.2.</strong> Component</a></li><li class="chapter-item expanded "><a href="ECS/system.html"><strong aria-hidden="true">4.3.</strong> System</a></li><li class="chapter-item expanded "><a href="ECS/iterators.html"><strong aria-hidden="true">4.4.</strong> Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="chai_components.html"><strong aria-hidden="true">5.</strong> Chai Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Components/visual_transform.html"><strong aria-hidden="true">5.1.</strong> VisualTransform</a></li><li class="chapter-item expanded "><a href="Components/sprite_component.html"><strong aria-hidden="true">5.2.</strong> SpriteComponent</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Chai Data Types</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="DataTypes/vector2f.html"><strong aria-hidden="true">6.1.</strong> Vector2f</a></li><li class="chapter-item expanded "><a href="DataTypes/rgba8.html"><strong aria-hidden="true">6.2.</strong> RGBA8</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Chai Resources</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Resources/texture.html"><strong aria-hidden="true">7.1.</strong> Texture</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chai Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="home"><a class="header" href="#home">Home</a></h1>
<p><em><strong>I would like to take a few lines to thank you, oh reader. for choosing to take some time off of your day and check this lightweight and humble engine.
This engine is the culmination of my very basic understanding of the underworkings of Game Engines,<br>
Beware though, for this engine might make you want to pluck your hairs, please bear with it.</strong></em></p>
<!-- ![Chai Logo](../resources/Chai_Logo_transparent.png) -->
<img src="../resources/Chai_Logo_transparent.png" class="logo">
<h3 id="tools-required"><a class="header" href="#tools-required">Tools Required</a></h3>
<ul>
<li>Go programming language</li>
<li>A modern web browser</li>
<li>A tool for hosting local servers (node/python)</li>
</ul>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<ul>
<li>Clone this repo <a href="https://github.com/mhamedGd/chai_examples">Chai Examples</a>.</li>
<li>Run "go get" in the root directory.</li>
<li>If you're using vscode then you can start right away, If you're using another code edit then you'd need to configure go for WASM build settings locally.</li>
</ul>
<h3 id="specifics"><a class="header" href="#specifics">Specifics</a></h3>
<ul>
<li>
<p>Chai is 2D, Web-focused, and Lightweight engine.</p>
</li>
<li>
<p>It uses WebAssembly through Go's WASM compiler to build Apps for the web.</p>
</li>
<li>
<p>Chai is an ECS based Game Engine. Which means that unlike OOP based Engines, Chai separates Logic from Data. Making the Components and Entities only data holders and identifiers. And having the logic be commonolized (generalized) amongst the specified components.</p>
</li>
<li>
<p>Current Cull Render Benchmark for Quads (no sprites) <a href="https://www.youtube.com/watch?v=YeYom1glrAk&amp;feature=youtu.be">Video</a></p>
</li>
</ul>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p><strong>In the "Chai Examples" folder, run:</strong></p>
<ul>
<li><strong>make build</strong> <em>Building the project</em></li>
<li><strong>make serve</strong> <em>Creating a local server for the project and opening it in the browser</em></li>
<li><strong>make run</strong> <em>Combines build and serve</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application"><a class="header" href="#application">Application</a></h1>
<pre><code class="language-go">type App struct {
	Width    int
	Height   int
	Title    string
	OnStart  func()
	OnUpdate func(float32)
	OnDraw   func(float32)
	OnEvent  func(*AppEvent)
}
</code></pre>
<p>An application is Chai's main entry point. It contains your App's info and life cycle.
It can be declared as a variable of type App.</p>
<pre><code class="language-go">var app chai.App = chai.App {
    Title: "",
    Width: 1920,
    Height: 1080,
    OnStart: func(){},
    OnUpdate: func(_delta_time float32){},
    OnDraw: func(_delta_time float32){},
    OnEvent func(_event *AppEvent){},
}
</code></pre>
<p>In order to run the Application, All You have to do is call "chai.Run(<em>application_variable_pointer</em>)" in the main file of your go project.</p>
<pre><code class="language-go">func main() {
    chai.Run(&amp;app)
}
</code></pre>
<p>If you try running <strong>make run</strong>, You'll get a looooong stream of errors in the console of the page. If you go all the way to the top you'll eventually see "Scene is set to none".</p>
<p>So next, we'll be discussing scenes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<pre><code class="language-go">type Scene struct {
	Background     RGBA8
	Ecs_World      *ecs.World
	start_systems  List[func(*Scene)]
	update_systems List[func(*Scene, float32)]
	render_systems List[func(*Scene, float32)]
	tags           Map[string, List[EntId]]
}

</code></pre>
<p>A scene is the container of your level's objects and logic. It is on align with Unity's understanding of a scene, Which states that scenes and objects (prefabs) are separate unlike Godot's.</p>
<p>You can create a scene inside an App's OnStart method.</p>
<pre><code class="language-go">OnStart: func(){
    _test_scene := chai.NewScene()
}
</code></pre>
<p>As we mentioned Chai is an ECS based Game Engine, Which means that Objects only contain data, while the logic is cluttered somewhere else</p>
<p>It goes like this</p>
<ul>
<li>Components are data holders (name, position, uv, speed, etc...)</li>
<li>Entities are Identifiers that point towards the specific component</li>
<li>Systems use the Entities to Get All the Components you would want to do logic on.</li>
</ul>
<h3 id="entities"><a class="header" href="#entities"><strong>Entities</strong></a></h3>
<p>An Entity is just an Id (uint32), Entities can be seen as a key in a dictionary. The key points to a specific value. And as such you can retrieve and manipulate the value thanks to the key pointing to its location.</p>
<p>In Game Engines, You'd typically think of Entities as Objects that hold <strong>Data</strong> and perform <strong>Logic</strong>. In ECS this definition would get dissected.</p>
<p><strong>Creating An Entity</strong> is very easy,</p>
<pre><code class="language-go">_entity := _test_scene.NewEntityId()
</code></pre>
<h3 id="components"><a class="header" href="#components"><strong>Components</strong></a></h3>
<p>A Component is any piece of data. Whether that be a struct or a native type, It can be turned into a component</p>
<pre><code class="language-go">type CustomComponent struct{
    u int
}
</code></pre>
<pre><code class="language-go">_entity := _test_scene_NewEntityId()
_component := CustomComponent{
    u: 0
}
_test_scene.AddComponents(_entity, chai.ToComponent(_component))
</code></pre>
<p>With this, The Engine has acknowledged that on this Scene, The component "_component" has been attached to this Identifier "_entity".</p>
<p><strong>Now how do we manipulate the component?</strong>
In Unity it would be something like getting a reference of the component in your script and then use it inside the script itself.</p>
<p>In Godot, You would either use the Node you've attached the script to or Get a reference to the Node you would want to manipulate.</p>
<p>Chai also needs to get a reference to the Component to use it like any other Engine, but the way we do that is different, Which takes us to <strong>Systems</strong>.</p>
<h3 id="systems"><a class="header" href="#systems"><strong>Systems</strong></a></h3>
<p>Systems are basically functions. They perform just like you would perform a function being called inside "Start" or "Update" in Unity(_ready, _process in Godot).</p>
<p><strong>Writing A System</strong></p>
<pre><code class="language-go">func CustomSystem(_this_scene *chai.Scene) {
    chai.LogF("Chaiiii")
}
</code></pre>
<p>Then you would need to add it to the scene.</p>
<pre><code class="language-go">_entity := _test_scene_NewEntityId()
_component := CustomComponent{
    u: 0
}
_test_scene.AddComponents(_entity, chai.ToComponent(_component))

_test_scene.NewStartSystem(CustomSystem)
</code></pre>
<p><strong>NewStartSystem</strong> is exactly that, It adds the System we just created into the Scene's Start runtime
Now what is a <strong>Scene runtime</strong>?</p>
<p>We'll be talking about it next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<p>Runtime is the concept of the Scene's run cycle, The Scene starts with "Start" Then it goes into cycling between "Update" and "Draw" every frame.</p>
<p><strong>There are 3 different Runtime:</strong></p>
<ul>
<li>Start</li>
<li>Update</li>
<li>Draw</li>
</ul>
<h3 id="start"><a class="header" href="#start">Start</a></h3>
<p>Start is called only once, At the start of the scene. It's useful for setting up the scene and creating Entities and Components.</p>
<p><strong>Adding A Start Runtime System</strong></p>
<pre><code class="language-go">func CustomSystem(_this_scene *chai.Scene) {

}
</code></pre>
<pre><code class="language-go">OnStart: func(){
    _test_scene := chai.NewScene()

    _test_scene.NewStartSystem(CustomSystem)
}
</code></pre>
<p>The first code is how you make a Start Runtime System. You just create a normal function and as a parameter you give a pointer of the scene this system will running on.</p>
<pre><code class="language-go">import (
	chai "github.com/mhamedGd/chai"
)

func CustomSystem(_this_scene *chai.Scene) {
    chai.LogF("Chai!!")
}

var app chai.App = chai.App{
    Title: "Docs",
    Width: 480,
    Height: 480,
    OnStart: func(){
        _test_scene := chai.NewScene()
        _test_scene.NewStartSystem(CustomSystem)

// Transition into this scene
        chai.ChangeScene(&amp;_test_scene)
    },
}

func main(){
    chai.Run(&amp;app)
}
</code></pre>
<p>Try then to run it "make run", Now the Output Should be like this.</p>
<p><em><strong>You can Access the Console with (Ctrl/Cmd + L.Shift + C)</strong></em></p>
<p><img src="../resources/start_runtime.png" alt="Start Output" /></p>
<h3 id="update"><a class="header" href="#update">Update</a></h3>
<p>Update just like Start is a runtime of Scene, but unlike Start it runs for every frame after Start, It's useful for game logic,</p>
<p><strong>Adding An Update Runtime System</strong></p>
<pre><code class="language-go">func CustomUpdateSystem(_this_scene *chai.Scene, _dt float32) {

}
</code></pre>
<pre><code class="language-go">OnStart: func(){
    _test_scene := chai.NewScene()

    _test_scene.NewUpdateSystem(CustomUpdateSystem)
}
</code></pre>
<p>Notice how here the Update Runtime System takes 2 parameters, not 1.
The first is a reference to the Scene the System is running on, While the Second is the delta-time of the updated frame.</p>
<pre><code class="language-go">import (
	chai "github.com/mhamedGd/chai"
)

func CustomUpdateSystem(_this_scene *chai.Scene, _dt float32) {
    chai.LogF("Chai Deltatime: %v", _dt)
}

var app chai.App = chai.App{
    Title: "Docs",
    Width: 480,
    Height: 480,
    OnStart: func(){
        _test_scene := chai.NewScene()
        _test_scene.NewUpdateSystem(CustomUpdateSystem)

// Transition into this scene
        chai.ChangeScene(&amp;_test_scene)
    },
}

func main(){
    chai.Run(&amp;app)
}
</code></pre>
<p>Try it now with "make run"</p>
<p><img src="../resources/update_runtime.png" alt="Update Runtime" /></p>
<h3 id="draw"><a class="header" href="#draw">Draw</a></h3>
<p>Draw is almost exactly the same as Update, the Difference is that it runs after Update in the Scene Life Cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecs"><a class="header" href="#ecs">ECS</a></h1>
<p>Chai is a an ECS based game engine, That means it ditches the traditional way of handling objects and logic and instead resorts to separating the logic from entities (objects)</p>
<h2 id="ecs-workings"><a class="header" href="#ecs-workings">ECS Workings</a></h2>
<p>The way an ECS system works is by defining Entities that have Components attached to them and then applying logic unto those Components by exploiting Systems</p>
<p>If we compare the normal regular game engine, How you would normally go on implementing a new mechanic is that you would usually create a new Component or a Script attached to the Component. You would put the logic and the data required by the mechanic in the same section (class, script, etc...). And as such the Engine would loop through all Entities (Objects) in the scene and executes the logic provided by each component attached to the Entity.</p>
<p>In ECS it's a bit different. When you write a Component, You only fill it with data without any logic. You would attach this Component to an Entity, and By using a System you would be able to loop through all Entities with the required Component and execute the logic you want using the data provided by the Components.
This way, the logic is separate from the data and like that not only would it be cache friendly, it would also be more scalable since you would treat Entities with Components as data pointers and holders.</p>
<p>It probably sounded confusing but believe me, when you use it, you would feel way more comfortable dealing with it compared to a regular Entities/Components Engine.</p>
<p><a href="https://www.reddit.com/r/gamedev/comments/257mt1/entity_component_system_vs_entity_component/">Read this to have a broader view on the topic</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity"><a class="header" href="#entity">Entity</a></h1>
<p>An Entity is just an Identifier of type (uint32). It literally is just a number that points to multiple Components.
When you create a new Entity you get an Identifier, You use this Identifier to Attach Components to this Entity. Now you would ask, How can I attach Components to a uint32? It literally cannot hold any data other than of type unsigned int of siz 32 bit. Well here the magic of ECS starts working. What the ECS Engine in Chai would do is identifiy those Components added with this Identifier and as such it would be able to retrieve them efficiently.</p>
<p><strong>Creating a New Entity</strong></p>
<pre><code class="language-go">func TestSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()
}
</code></pre>
<p><em>If we print it out with "chai.LogF()" we get the following</em></p>
<p><strong>Output</strong></p>
<pre><code class="language-go">2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component"><a class="header" href="#component">Component</a></h1>
<p>A Component can be anything, A struct or an int or anything can become a Component. Using a converter method, You can have a custom type holding X data become a Component that interacts with the ECS Engine in the Scene.</p>
<p>You can then attach them to you Entity this way.</p>
<br>
<h3 id="attaching-a-component-to-an-entity"><a class="header" href="#attaching-a-component-to-an-entity">Attaching a Component to an Entity</a></h3>
<pre><code class="language-go">type Custom struct {
    data int
}

func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 0,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))
}
</code></pre>
<br>
<p><em><strong>Notice the "ToComponent" method. This method converts any type of data to a component that you can attach to your Entity</strong></em></p>
<h3 id="getting-the-component"><a class="header" href="#getting-the-component">Getting the Component</a></h3>
<pre><code class="language-go">type Custom struct {
    data int
}

func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 0,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))

    _c, ok := chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)
}
</code></pre>
<p><em><strong>output</strong></em></p>
<p><img src="ECS/../../resources/get_component.png" alt="Get Component Output" /></p>
<br>
<h3 id="removing-a-component"><a class="header" href="#removing-a-component">Removing a Component</a></h3>
<p>DestroyComponent[T any](scene *Scene, entityId EntId)</p>
<pre><code class="language-go">func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 10,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))

    _c, ok := chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)
    
    chai.DestroyComponent[Custom](_this_scene, _entity)
    _c, ok = chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)

}
</code></pre>
<p><strong>output</strong></p>
<p><img src="ECS/../../resources/destroy_component.png" alt="Destroy Component Output" /></p>
<br>
<h3 id="modifying-a-component"><a class="header" href="#modifying-a-component">Modifying a Component</a></h3>
<p>You can modify a Component by getting the Pointer of the Component and then modifying the underlying data directly</p>
<pre><code class="language-go">func CustomSceneStart(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()

    _component := Custom {
        data: 10,
    }

    _this_scene.AddComponents(_entity, chai.ToComponent(_component))

    _c, ok := chai.GetComponent[Custom](_this_scene, _entity)
    chai.LogF("Does Scene Exist? %v, Custom Struct: %v", ok, _c)
    
    _cPtr := chai.GetComponentPtr[Custom](_this_scene, _entity)
    _cPtr.data = 20
    chai.LogF("Custom Struct: %v", _cPtr)
}
</code></pre>
<p><strong>output</strong>
<img src="ECS/../../resources/get_component_ptr.png" alt="Get ComponentPtr Output" /></p>
<h3 id="keep-in-mind-that-a-components-pointer-might-change-everytime-you-add-a-new-component-so-it-is-not-advised-to-keep-the-pointer-stored-in-a-variable-for-you-to-use-it-throughout-the-applications-lifetime"><a class="header" href="#keep-in-mind-that-a-components-pointer-might-change-everytime-you-add-a-new-component-so-it-is-not-advised-to-keep-the-pointer-stored-in-a-variable-for-you-to-use-it-throughout-the-applications-lifetime">Keep in mind that a Component's Pointer might change everytime you add a new Component, So it is not advised to keep the pointer stored in a variable for you to use it throughout the Application's Lifetime.</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system"><a class="header" href="#system">System</a></h1>
<p>Systems are the executers of logic. They are the equivalent of "void Start", void "Update" in Unity, They hook unto the main application loop. Using Systems you can easily implement features in your game thanks to their flexible and modular usage.
In a Scene, there are 3 runtimes:</p>
<ul>
<li>Start</li>
<li>Update</li>
<li>Render</li>
</ul>
<p>Each runtime can have functions be subscribed to, and those functions will be called according to their order of addition.</p>
<p><strong>Here's an Example</strong></p>
<pre><code class="language-go">func TestStartSystem(_this_scene *chai.Scene) {
    chai.LogF("Test System")
}
</code></pre>
<p>Here we declare a new function with a single parameter "_this_scene" of type (Pointer to Scene). All the function does is print a message to the console.</p>
<hr />
<br>
<p><strong>How can I subscribe it to a runtime?</strong></p>
<h3 id="start-runtime"><a class="header" href="#start-runtime">Start Runtime</a></h3>
<pre><code class="language-go">var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(TestStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}
</code></pre>
<p>Here we're subscribing it to the start system of the Scene runtime, That means the function will get called when we first start the Scene.</p>
<p>The reason the function takes a parameter of a pointer to a Scene is that the runtime will pass the scene the function is currently subcribed to through this parameter, for the user to modify.</p>
<h4 id="the-start-runtime-is-usually-used-to-setup-the-scene-and-adding-entities-to-the-scene"><a class="header" href="#the-start-runtime-is-usually-used-to-setup-the-scene-and-adding-entities-to-the-scene">The Start runtime is usually used to setup the Scene and adding Entities to the Scene</a></h4>
<h3 id="update-runtime"><a class="header" href="#update-runtime">Update Runtime</a></h3>
<pre><code class="language-go">func TestUpdateSystem(_this_scene *chai.Scene, _delta float32) {
    chai.LogF("Test System")
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewUpdateSystem(TestUpdateSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}
</code></pre>
<p>Here we'e subscribing to the Update system of the Scene runtime, That means the function will get called once per frame during the lifetime of the game.</p>
<p>It takes 2 parameters, 1st is the current Scene pointer, and the 2nd is the delta-time between the current frame and the previous frame.</p>
<h4 id="the-update-runtime-is-useful-for-applying-game-logic-and-implementing-features"><a class="header" href="#the-update-runtime-is-useful-for-applying-game-logic-and-implementing-features">The Update runtime is useful for applying game logic and implementing features</a></h4>
<h3 id="render-runtime"><a class="header" href="#render-runtime">Render Runtime</a></h3>
<pre><code class="language-go">func TestRenderSystem(_this_scene *chai.Scene, _delta float32) {
    chai.LogF("Test System")
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewRenderSystem(TestRenderSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}
</code></pre>
<p>Here we'e subscribing to the Render system of the Scene runtime, That means the function will get called once per frame during the lifetime of the game.</p>
<p>It takes 2 parameters, 1st is the current Scene pointer, and the 2nd is the delta-time between the current frame and the previous frame.</p>
<h4 id="the-render-runtime-is-useful-for-calling-custom-drawing-commands-during-runtime"><a class="header" href="#the-render-runtime-is-useful-for-calling-custom-drawing-commands-during-runtime">The Render runtime is useful for calling custom drawing commands during runtime</a></h4>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p><strong>Let's use what we just learned to create an App that has a spinning square in the middle</strong></p>
<pre><code class="language-go">var rectRotation float32 = 0.0

func RectStartSystem(_this_scene *chai.Scene) {
    _this_scene.NewUpdateSystem(RectUpdateSystem)
	_this_scene.NewRenderSystem(RectRrenderSystem)
	
	chai.Shapes.LineWidth = 1
}

func RectUpdateSystem(_this_scene *chai.Scene, _delta float32) {
    rectRotation += _delta * 5.0
}

func RectRenderSystem(_this_scene *chai.Scene, _delta float32) {
	chai.Shapes.DrawRectRotated(chai.Vector2fZero, 0.0, chai.NewVector2f(20.0, 20.0), chai.WHITE, rectRotation)
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(RectStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}

func main(){
	chai.Run(&amp;app)
}
</code></pre>
<p><strong>output</strong></p>
<p><img src="ECS/../../resources/systems_example.gif" alt="Example Output" /></p>
<hr />
<p><strong>There's a lot to unfold here</strong></p>
<ul>
<li>We declared a new variable that will hold the Rect's rotation.</li>
<li>We declared a new function that will be added to the Start runtime.</li>
<li>Now instead of subscribing the Update and Render functions in the "OnStart" function, we did it in the Start runtime function, Why? So that this turns this function into a template, So that if any other scene would like similar results then all they need is to subscribe this function to their Start runtime.</li>
<li>We change the value of a float "LineWidth", inside an object called Shapes belonging to Chai.</li>
<li>In the Update function, we're only incrementing the rotation.</li>
<li>Now in the Render function, we're calling onto an object in chai called "Shapes" that holds all the functions needed to draw Shapes onto the screen, then we're calling the function "DrawRectRotated" that takes in
<ul>
<li>Center</li>
<li>Z</li>
<li>Dimensions</li>
<li>Color</li>
<li>Rotation (in degrees)</li>
</ul>
</li>
<li>Then we run the app in main</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>Iteratos are a way provided by the ECS Engine to iterate over Entities that have X Component attached to it.</p>
<p>Let's say you created a new Entity and attached a Rigidbody Component to it. Now in Update you want to apply continuos force to that Rigidbody. How would you go about that? Would you need to get that Component's Pointer every-frame? That seems like a lot of processing overhead.</p>
<p>And here comes the usefulness of ECS Iterators.</p>
<p>Check this Example.</p>
<pre><code class="language-go">type CustomComponent struct {
    data int
}

func IterateStartSystem(_this_scene *chai.Scene) {
    _this_scene.NewUpdateSystem(RectUpdateSystem)

    _entity := _this_scene.NewEntityId()
    _custom_component := CustomComponent{data: 10}
    _this_scene.AddComponents(_entity, chai.ToComponent(_custom_component))
}

func IterateUpdateSystem(_this_scene *chai.Scene, _delta float32) {
    chai.Iterate1[CustomComponent](func(i ecs.Id, c *CustomComponent){
        chai.LogF("CustomComponent: %v", c.data)
    })
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(IterateStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}

func main(){
	chai.Run(&amp;app)
}
</code></pre>
<p><strong>output</strong></p>
<p><img src="ECS/../../resources/iterate_1.png" alt="Iterate1 Example Output" /></p>
<p>We need to explain a few statements in the previous example.</p>
<p>We can see the usual of subsribing a Start runtime function and an Update runtime function, and then we create a new Entity and attach a custom component.
In "IterateUpdateSystem" we see that we're calling a new function "Iterat1" that takes a generic of type [CustomComponent] and as a parameter it takes a function that needs 2 parameters, <strong>1st is an Entity id, and 2nd is a pointer to "CustomComponent".</strong></p>
<p>What Iterate1[CustomComponent] does is it <strong>iterates on all entities with a CustomComponent type Component attached to it</strong> and then it executes the callback provided in it as a parameter:</p>
<pre><code>Iterate[CustomComponent](A Function that does something with the Entity)
</code></pre>
<p>and the callback function provides 2 parameters, 1st is the Entity that has CustomComponent attached and 2nd is a pointer to the CustomComponent attached to it.</p>
<p><em>You don't have to use a closure function, You can provide an external function that takes the same parameters as the closure does</em></p>
<h3 id="multiple-components"><a class="header" href="#multiple-components">Multiple Components?</a></h3>
<p>You can iterate over Entities with more than 1 Component using</p>
<pre><code>chai.Iterate2[A, B](func(i ecs.Id, a *A, b *B))
chai.Iterate3[A, B, C](func(i ecs.Id, a *A, b *B, c *C))
chai.Iterate4[A, B, C, D](func(i ecs.Id, a *A, b *B, c *C, d *D))
chai.Iterate4[A, B, C, D, E](func(i ecs.Id, a *A, b *B, c *C, d *D, e *E))
</code></pre>
<p>You can use any of the previous functions to iterate over entities that contain the provided components inside the brackets "[]".</p>
<p><strong>chai.Iterate1[A], Iterates over all Entities who have this Component attached to them and not Entities who only have this Component attached to them</strong>, the other Iterate functions work the same way.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>Let's use what we learned so far to create an App that draws 3 rects.</p>
<pre><code class="language-go">type CustomComponent struct {
    xOffset float32
}

func RectStartSystem(_this_scene *chai.Scene) {
    _this_scene.NewRenderSystem(RectRenderSystem)
    chai.Shapes.LineWidth = 1.5
    
    _entity1 := _this_scene.NewEntityId()
    _custom_component1 := CustomComponent{xOffset: 120}
    _this_scene.AddComponents(_entity1, chai.ToComponent(_custom_component1))
    
    _entity2 := _this_scene.NewEntityId()
    _custom_component2 := CustomComponent{xOffset: 0}
    _this_scene.AddComponents(_entity2, chai.ToComponent(_custom_component2))
    
    _entity3 := _this_scene.NewEntityId()
    _custom_component3 := CustomComponent{xOffset: -120}
    _this_scene.AddComponents(_entity3, chai.ToComponent(_custom_component3))
}

func RectRenderSystem(_this_scene *chai.Scene, _delta float32) {
    chai.Iterate1[CustomComponent](func(i ecs.Id, c *CustomComponent){
        chai.Shapes.DrawRectRotated(chai.NewVector2f(c.xOffset, 0.0), 0.0, chai.NewVector2f(20.0, 20.0), chai.WHITE, 0.0)
    })
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(RectStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}

func main(){
	chai.Run(&amp;app)
}
</code></pre>
<p><strong>output</strong></p>
<p><img src="ECS/../../resources/iterator_rect.png" alt="Iterator&amp;Entity Example" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chai-components"><a class="header" href="#chai-components">Chai Components</a></h1>
<p>Just like you can create Components, So can the Author of Chai. He especially created some Comopnents to ease your experience in Chai.</p>
<p>There's a number of Components provided by Chai that completes the Game Development Experience. All the Components listed next are not necessary if you want to use Chai as a framework, but if you to use Chai as an engine then please use what I wroked hard to make.</p>
<p>Some components are necessary for almost every Entity, some are required for accessing some functionalities in Chai.</p>
<p><em><strong>It's important to note that all Chai authored Componenets follow the naming convention of suffixing the Component's name with the word "Component", except for VisualTransform.</strong></em></p>
<p><em>Moreover all Chai authored Components have builder functions that follow the Convention "New" + Name of Component, With the exception of this rule being the "VisualTransform" Component as well.</em></p>
<p><strong>Components:</strong></p>
<ul>
<li><a href="./Components/visual_transform.html">VisualTransform</a></li>
<li><a href="./Components/sprite_component.html">SpriteComponent</a></li>
<li><a href="./Components/quad_component.html">QuadComponent</a></li>
<li><a href="./Components/line_component.html">LineComponent</a></li>
<li><a href="./Components/font_render_component.html">FontRender</a></li>
<li><a href="./Components/sprite_animation_component.html">SpriteAnimationComponent</a></li>
<li><a href="./Components/animation_component.html">AnimationComponent</a></li>
<li><a href="./Components/dynamic_body_component.html">DynamicBodyComponent</a></li>
<li><a href="./Components/static_body_component.html">StaticBodyComponent</a></li>
<li><a href="./Components/kinematic_body_component.html">KinematicBodyComponent</a></li>
<li><a href="./Components/audio_source_component.html">AudioSourceComponent</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visualtransform"><a class="header" href="#visualtransform">VisualTransform</a></h1>
<pre><code class="language-go">type VisualTransform struct {
	Position   Vector2f
	Z          float32
	Dimensions Vector2f
	Rotation   float32
	Scale      float32
	Tint       RGBA8
	UV1        Vector2f
	UV2        Vector2f
}
</code></pre>
<p>This is the most used and fundamental Component offered by Chai, It offers information regarding everything that has to do with the Entity's visual representation.</p>
<p><strong>Position:</strong> The Entity's location. It takes a Vector2f (Refer to <a href="Components/../DataTypes/vector2f.html">Vector2f</a>).</p>
<p><strong>Z:</strong> The Entity's distance from the Camera, It can range (0.0 -&gt; 1000.0). It also represents the Entity's drawing order, The higher it is the further it is from the camera, the lower its drawing order is.</p>
<p><strong>Dimensions:</strong> The Entity's Dimensions. It takes a Vector2f.</p>
<p><strong>Rotation:</strong> The Entity's Rotation.</p>
<p><strong>Scale:</strong> The Entity's Scale, Which is multiplied by the Dimensions to give the final Entity size.</p>
<p><strong>Tint:</strong> The Entity's tint (color or modulance), It takes an RGBA8.</p>
<p><strong>UV1:</strong> The Entity's starting Texture Coordinates. It takes a Vector2f.</p>
<p><strong>UV2:</strong> The Entity's ending Texture Coordinates. It takes a Vector2f.</p>
<hr />
<h3 id="creating-a-visualtransform-component"><a class="header" href="#creating-a-visualtransform-component"><strong>Creating a VisualTransform Component</strong></a></h3>
<pre><code class="language-go">func SceneStartSystem(_this_scene *chai.Scene) {    
    _entity := _this_scene.NewEntityId()
    _vt := chai.VisualTransform{
        Position: chai.NewVector2f(0.0, 0.0),
        Z: 0.0,
        Dimensions: chai.NewVector2f(0.0, 0.0),
        Rotation: 0.0,
        Scale: 1.0,
        UV1: chai.Vector2fZero,
        UV2: chai.Vector2fOne,
    }
    
    _this_scene.AddComponents(_entity, chai.ToComponent(_vt))
    
    _vt_comp, _ := chai.GetComponent[chai.VisualTransform](_this_scene, _entity)
    
    chai.LogF("[Entity VisualTransform]: %v", _vt_comp)

}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(SceneStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}

func main(){
	chai.Run(&amp;app)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spritecomponent"><a class="header" href="#spritecomponent">SpriteComponent</a></h1>
<pre><code class="language-go">type SpriteComponent struct {
	Texture Texture2D
}
</code></pre>
<p>This Component is referred to as a Mark Component, for it only marks the Entity for functionality and does not contriubte to the Rendering of the Sprite itself.</p>
<p><em>What do we mean?</em></p>
<pre><code class="language-go">_entity := _this_scene.NewEntityId()
_vt := chai.VisualTransform{
    Position: chai.NewVector2f(0.0, 0.0),
    Z: 0.0,
    Dimensions: chai.NewVector2f(100.0, 100.0),
    Rotation: 0.0,
    Scale: 1.0,
    UV1: chai.Vector2fZero,
    UV2: chai.Vector2fOne,
}
_sprite_component := chai.NewSpriteComponent(_this_scene, _entity, _vt, ..., false)

_this_scene.AddComponents(_entity, chai.ToComponent(_vt), chai.ToComponent(_sprite_component))
</code></pre>
<p><em>This code will not run</em></p>
<p>The previous script creates an Entity with a VisualTransform and then using the Entity and the VisualTransform, it creates a SpriteComponent with the method "NewSpriteComponent".
Using this we tell Chai that we want a Sprite to be drawn with relation to this Entity and VisualTransform, Using this we can manipulate the VisualTransform of the Entity and it will Update dynamically without the need of Adding any System by default.</p>
<p><strong>The method NewSpriteComponent() takes a pointer to the current Scene, the Entity to be paired to, the Visual Transform of that Entity, A pointer to a Texture type (...), and a boolean to see if it's this Entity is to be drawn Static or Not.</strong></p>
<p><em>Static means that in no way during the lifetime of the App you would change the values of the VisualTransform. It's useful for drawing Levels and Backgrounds.</em></p>
<p><strong>Now what do we need a SpriteComponent for if the drawing of the Sprite is being done without the use of the System part of Chai?</strong></p>
<p>It's quite useful when Iterating over Entities being drawn. Using it as a Mark Component, the Entity will be marked as having a Sprite attached to it and as such you can Iterate over it.</p>
<pre><code class="language-go">for (i:=0;i&lt;10;i++) {
    _entity := _this_scene.NewEntityId()
    _vt := chai.VisualTransform{
        Position: chai.NewVector2f(0.0, 0.0),
        Z: 0.0,
        Dimensions: chai.NewVector2f(100.0, 100.0),
        Rotation: 0.0,
        Scale: 1.0,
        UV1: chai.Vector2fZero,
        UV2: chai.Vector2fOne,
    }
    _sprite_component := chai.NewSpriteComponent(_this_scene, _entity, _vt, ..., false)
    
    _this_scene.AddComponents(_entity, chai.ToComponent(_vt), chai.ToComponent(_sprite_component))
}

chai.Iterate1[chai.SpriteComponent](func(i ecs.Id, sc *chai.SpriteComponent) {
    // Do Something With the Entity
})
</code></pre>
<p><em>This code will not run</em></p>
<h2 id="drawing-a-sprite"><a class="header" href="#drawing-a-sprite">Drawing a Sprite</a></h2>
<p>To draw a Sprite, You need a Sprite(Image). Loading an Image is Chai is very easy, Using the method "LoadPng" you can load an Image and return the Texture containing its Width, Height.</p>
<p><strong>How can I load a Texture?</strong> refer to <a href="Components/../Resources/texture.html">Texture Resource</a></p>
<p>After learning about Textures in Chai, Let's draw a Sprite:</p>
<pre><code class="language-go">func SceneStartSystem(_this_scene *chai.Scene) {
    _entity := _this_scene.NewEntityId()
    _vt := chai.VisualTransform{
        Position: chai.NewVector2f(0.0, 0.0),
        Z: 0.0,
        Dimensions: chai.NewVector2f(100.0, 100.0),
        Rotation: 0.0,
        Scale: 1.0,
        Tint, chai.WHITE,
        UV1: chai.Vector2fZero,
        UV2: chai.Vector2fOne,
    }
    _texture := chai.LoadPng("chai_logo.png")
    _sprite_component := chai.NewSpriteComponent(_this_scene, _entity, _vt, &amp;_texture, false)
    
    _this_scene.AddComponents(_entity, chai.ToComponent(_vt), chai.ToComponent(_sprite_component))
}

var app chai.App = chai.App{
	Title:  "Docs",
	Width:  480,
	Height: 480,
	OnStart: func() {
		_test_scene := chai.NewScene()
		_test_scene.NewStartSystem(SceneStartSystem)

		// Transition into this scene
		chai.ChangeScene(&amp;_test_scene)
	},
}

func main(){
	chai.Run(&amp;app)
}
</code></pre>
<p><img src="Components/../../resources/load_png.png" alt="Draw Sprite Output" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector2f"><a class="header" href="#vector2f">Vector2f</a></h1>
<pre><code class="language-go">type Vector2f struct {
	X float32
	Y float32
}
</code></pre>
<p><strong>Vector2f</strong> is used everywhere, It represents a Point in a 2D Coordinates system.</p>
<h3 id="creating-a-new-vector2f"><a class="header" href="#creating-a-new-vector2f"><strong>Creating a new Vector2f</strong></a></h3>
<pre><code class="language-go">_vec1 := chai.Vector2f{X:5.0, Y:1.0}
_vec2 := chai.NewVector2f(4.0, 1.0)
</code></pre>
<h3 id="operations-done-on-vector2f"><a class="header" href="#operations-done-on-vector2f"><strong>Operations Done On Vector2f</strong></a></h3>
<pre><code class="language-go">_vec1.Equal(_vec2) // returs a boolean, Check if 2 Vector2f are equal.

_vec1.NearlyEqual(_vec2) // returns a boolean, Check if 2 Vector2f are nearly equal (by margin of 0.001)

_vec1.Add(_vec2) // returns a Vector2f, Returns the added value of 2 Vector2f.

_vec1.AddXY(_vec2.X, _vec2.Y) // returns a Vector2f, Returns the added value of a Vector2f and 2 floats.

_vec1.Subtract(_vec2) // returns a Vector2f, Returns the subtracted value of 2 Vector2f.

_vec1.SubtractXY(_vect) // returns a Vector2f, Returns the subtracted value of 1 Vector2f and 2 floats.

_vec1.Multp(_vec2) // returns a Vector2f, Returns the multiplied value of 2 Vector2f.

_vec1.MultpXY(_vec2) // returns a Vector2f, Returns the multiplied value of 1 Vector2f and 2 floats.

_vec1.Div(_vec2) // returns a Vector2f, Returns the divided value of 2 Vector2f.

_vec1.Scale(2.0) // returns a Vector2f, Returns the scaled value of a Vector2f and a float (_vec1 * 2.0)

AbsVector2f(_vec1) // returns a Vector2f, Returns a absolute value of a Vector2f.

_vec1.Length() // returns a float, Returns the length of a Vector2f.

_vec1.LengthSquared() // returns a float, Returns the squared length of a Vector2f.

_vec1.Normalize() // returns a Vector2f, Returns a normalized value of a Vector2f.

_vec1.Distance(_vec2) // returns a float, Returns the distance between 2 Vector2f.

DotProduct(_vec1, _vec2) // returns a float32, Returns the Dot Product of 2 Vector2f.

_vec1.Perpendicular() // returns a Vector2f, Returns the Vector2f Perpendicular of the Vector2f provided.

_vec1.Angle() // returns a float, Returns the angle of a Vector2f in Radians.

_vec1.Rotate(90.0, _vec2) // returns a Vector2f, Returns the Rotated value of a Vector2f with a pivot from the Center (use a Zero Vector2f if you want it to rotate from the Center)

_vec1.RotateCenter(90.0) // returns a Vector2f, Returns the Rotated value of a Vector2f.

Vector2fMidpoint(_vec1, _vec2) // returns a Vector2f, Returns the Middle point between 2 Vector2f.

_vec1.ToString() // returns a string, Returns the Vector2f in a string format.

RandVector2f() // returns a Vector2f, Returns a Random Vector2f, its X and Y ranging (0.0, 1.0).

RandPosVector2f() // returns a Vector2f, Returns a Random Vector2f, its X and Y ranging (-1.0, 1.0).
</code></pre>
<h3 id="vector2f-usage"><a class="header" href="#vector2f-usage"><strong>Vector2f Usage</strong></a></h3>
<pre><code class="language-go">_new_vec := _vec1.Add(_vec2).Scale(3.0).Rotate(45.0, chai.Vector2f(0.0, 0.0)).Normalize()
chai.LogF("New Vec: "+ _new_vec.ToString())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rgba8"><a class="header" href="#rgba8">RGBA8</a></h1>
<pre><code class="language-go">type RGBA8 struct {
	r, g, b, a uint8
}
</code></pre>
<p>Represents the Color data type in Chai, It uses unsigned integers (8-bit) to represent the default (RGBA) values used by most Color Wheels (Red, Green, Blue, and Alpha ranging from 0 to 255).</p>
<h3 id="creating-a-new-rgba8"><a class="header" href="#creating-a-new-rgba8"><strong>Creating a new RGBA8</strong></a></h3>
<pre><code class="language-go">_color1 := chai.RGBA8{255, 255, 255, 255}
_color2 := chai.NewRGBA8(255, 255, 255, 255)
_color3 := chai.NewRGBA8Float(1.0, 1.0, 1.0, 1.0)
</code></pre>
<h3 id="how-to-manipulate-an-rgba8"><a class="header" href="#how-to-manipulate-an-rgba8"><strong>How to Manipulate an RGBA8?</strong></a></h3>
<pre><code class="language-go">_color1.SetColorR(100)
_color1.SetColorBFloat32(0.35)
_color1.SetColorA(0.0)
_color1.SetColorAFloat32(1.0)


chai.LogF("Color: %v", _color1)
</code></pre>
<h3 id="rgba8-methods"><a class="header" href="#rgba8-methods"><strong>RGBA8 Methods</strong></a></h3>
<pre><code class="language-go">chai.LogF("[Color]: %v", chai.GetRandomRGBA8()) // Returns a Random Color.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="texture"><a class="header" href="#texture">Texture</a></h1>
<pre><code class="language-go">type Texture2D struct {
	Width, Height int
	textureId js.Value
	spwidth, spheight  int
}
</code></pre>
<p><strong>Width:</strong> Loaded image width</p>
<p><strong>Height:</strong> Loaded image height</p>
<p><strong>textureId:</strong> private variable referring to the Texture Id</p>
<p><strong>spwidth:</strong> private variable referring to the Single Sprite Width, useful when loading a SpriteSheet.</p>
<p><strong>spheight:</strong> private variable referring to the Single Sprite Height, useful when loading a SpriteSheet.</p>
<hr />
<h3 id="how-can-we-create-a-texture"><a class="header" href="#how-can-we-create-a-texture"><strong>How can we create a Texture?</strong></a></h3>
<pre><code class="language-go">func LoadPng(_file_path string, _texture_settings TextureSettings) Texture2D
</code></pre>
<p><strong>_file_path:</strong> Local path of the output files (index.html) to the png image file.
<strong>Important to note that the path must not begin with a forward slash '/'.</strong></p>
<p><strong>_texture_settings:</strong> Configured settings of loading the png</p>
<pre><code class="language-go">type TextureSettings struct {
	Filter TextureFilter
}
</code></pre>
<p>There is only one settings currently, A filter.</p>
<p>Filters:</p>
<ul>
<li><strong>TEXTURE_FILTER_LINEAR</strong> for smoothing the colors (Useful for high-res art).</li>
<li><strong>TEXTURE_FILTER_NEAREST</strong> for displaying the pixels directly (Useful for pixel art).</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
